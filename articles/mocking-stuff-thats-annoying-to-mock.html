<!DOCTYPE html>
<html>
  <head>
    <title>lemonjs / articles / Mocking stuff that's annoying to mock</title>
    <meta name="description" content="Just another developer's blog">
    <meta name="keywords" content="Blog, TypeScript, Python, Running, Coffee">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="Lewis Monteith">
    <meta property="og:title" content="Mocking stuff that's annoying to mock">
    <meta property="og:description" content="I recently attended a workshop where a coworker demoed a Dependency Injection framework he'd written. He pitched it as a way to reduce complexity in their Serverless Python application, and as a way to simplify the unit testing. It got me thinking about how mocking the global scope of some of our dependencies was a huge PITA and that we could leverage some DI.">
    <meta property="og:url" content="https://lemonjs.uk/mocking-stuff-thats-annoying-to-mock.html">
    <meta property="og:image" content="https://lemonjs.uk/social-bg.png">
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="630" />
    <meta property="og:site_name" content="lemonjs">
    <meta name="theme-color" content="#2f3640">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/manifest.json">
    <link rel="stylesheet" href="/main.css">
  </head>
  <body>
    <div class="container">
      <header class="header">
        <h3>A bunch of nonsense, by Lewis Monteith</h3>
        <p>
          <a href="/">< Back</a>
        </p>
      </header>
      <main>
          <article>
            <h1>Mocking stuff that's annoying to mock</h1>
            <p>I recently attended a workshop where a coworker demoed a Dependency Injection framework he'd written. He pitched it as a way to reduce complexity in their Serverless Python application, and as a way to simplify the unit testing. It got me thinking about how mocking the global scope of some of our dependencies was a huge PITA and that we could leverage some DI.</p>

            <p>We've recently started moving a leaderboard from DynamoDB to Redis and we need a way to mock some of the calls to Redis. One option would be to use <a href="https://www.npmjs.com/package/ioredis-mock" target="_blank" rel="nofollow noreferrer">ioredis-mock</a>, a drop in library to stub out the entirety of Redis. Yarn installing a whole package just to write some tests seemed like the most javascripty thing ever!</p>

            <p>Here's how I imagine our code would be structured:</p>

              <pre><code class="hljs typescript"><span class="hljs-keyword">import</span> Redis <span class="hljs-keyword">from</span> <span class="hljs-string">'redis'</span>;

<span class="hljs-keyword">const</span> redis = <span class="hljs-keyword">new</span> Redis();

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> getLeaderboardEntry = <span class="hljs-keyword">async</span> (
    id: <span class="hljs-built_in">string</span>
): <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>&gt; =&gt; {
    <span class="hljs-keyword">return</span> redis.get(id);
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> deleteLeaderboardEntry = <span class="hljs-keyword">async</span> (
    id: <span class="hljs-built_in">string</span>
): <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; =&gt; {
    <span class="hljs-keyword">await</span> redis.del(id);
};</code></pre>

            <p>A bunch of exported functions all utlising the global redis instance. On the face of it, this code is okay, however it has it's downsides. Firstly, getting an item from the leaderboard is now tightly coupled both to Redis, and to the specific npm package for talking to Redis. Secondly, we need to mock the global scope.</p>

            <p>Without going head first into a DI framework, we could easilly rewrite this code as a class, where we take a CacheClient argument, like so:</p>

            <pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Leaderboard</span> </span>{
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> client: CacheClient;

  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">client: CacheClient</span>)</span> {
      <span class="hljs-built_in">this</span>.client = client;
  }

  <span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> get(id: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>&gt; {
      <span class="hljs-built_in">this</span>.client.get(id);
  }

  <span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">delete</span>(id: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; {
      <span class="hljs-built_in">this</span>.client.del(id);
  }
}</code></pre>
            <p>With a small change, we've decoupled the leaderboard from Redis, from ioredis, and made it possible to test without mocking the global scope, nice! A simple test can now be written to make sure the client is called correctly:</p>

              <pre><code class="language-typescript hljs">describe(<span class="hljs-string">'Leaderboard'</span>, <span class="hljs-function">() =&gt;</span> {
  describe(<span class="hljs-string">'.get'</span>, <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-keyword">const</span> client = { <span class="hljs-attr">get</span>: jest.fn(<span class="hljs-function">() =&gt;</span> <span class="hljs-string">'hello!'</span>) };

      it(<span class="hljs-string">'calls the client'</span>, <span class="hljs-keyword">async</span> () =&gt; {
          <span class="hljs-keyword">const</span> leaderboard = <span class="hljs-keyword">new</span> Leaderboard(client);
          <span class="hljs-keyword">await</span> leaderboard.get(<span class="hljs-string">'id'</span>);
          expect(client.get).toHaveBeenCalledWith(<span class="hljs-string">'id'</span>);
      });

      it(<span class="hljs-string">'returns the key'</span>, <span class="hljs-keyword">async</span> () =&gt; {
          <span class="hljs-keyword">const</span> leaderboard = <span class="hljs-keyword">new</span> Leaderboard(client);
          <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> leaderboard.get(<span class="hljs-string">'id'</span>);
          expect(result).toEqual(<span class="hljs-string">'hello'</span>);
      });
  });
});</code></pre>
            <p>Another option would be to use a Higher Order Function to inject the CacheClient, we could leverage all the benefits of the above class, but retain the 'just a bunch of exported functions' approach. Here's a basic wrapper:</p>
              <pre><code class="language-typescript hljs"><span class="hljs-keyword">import</span> Redis <span class="hljs-keyword">from</span> <span class="hljs-string">'ioredis'</span>;

<span class="hljs-keyword">const</span> redis = <span class="hljs-keyword">new</span> Redis();

<span class="hljs-keyword">const</span> withCacheClient = &lt;T extends Function, G&gt;(
    func: T,
    ...args: Array&lt;T&gt;
) =&gt; func(x, ...args);</code></pre>
            <p>If we modify the code from the first example to use this HOF, it would look like this:</p>
              <pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> getLeaderboardEntry = <span class="hljs-keyword">async</span> (
    client: CacheClient,
    <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>
): <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>&gt; =&gt; {
    <span class="hljs-keyword">return</span> client.get(id);
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> deleteLeaderboardEntry = <span class="hljs-keyword">async</span> (
    client: CacheClient,
    <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>
): <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; =&gt; {
    <span class="hljs-keyword">await</span> client.del(id);
};

<span class="hljs-comment">// Example usage</span>
<span class="hljs-keyword">async</span> withCacheClient(getLeaderboardEntry, <span class="hljs-string">'id'</span>);
<span class="hljs-keyword">async</span> withCacheClient(deleteLeaderboardEntry, <span class="hljs-string">'id'</span>);
</code></pre>
            <p>Once again, our application logic can be tested without the need to mock the global Redis instance, as we can pass a mocked version in ourselves:</p>

              <pre><code class="language-typescript hljs">describe(<span class="hljs-string">'getLeaderboardEntry'</span>, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> client = { <span class="hljs-attr">get</span>: jest.fn(<span class="hljs-function">() =&gt;</span> <span class="hljs-string">'Hello'</span>) };

    it(<span class="hljs-string">'returns the key'</span>, <span class="hljs-function">() =&gt;</span> {
        <span class="hljs-keyword">const</span> result = getLeaderboardEntry(redis, <span class="hljs-string">'id'</span>);
        expect(result).toEqual(<span class="hljs-string">'hello'</span>);
    });
});</code></pre>
          </article>
      </main>
    </div>
  </body>
</html>
