<!DOCTYPE html>
<html lang="en">

<head>
    <title>lemonjs / articles / Mocking stuff that's annoying to mock</title>
    <meta charset="utf-8">
    <meta name="description" content="Just another developer's blog">
    <meta name="keywords" content="Blog, TypeScript, Python, Running, Coffee">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="Lewis Monteith">
    <meta property="og:title" content="Mocking stuff that's annoying to mock">
    <meta property="og:description" content="I recently attended a workshop where a coworker demoed a Dependency Injection framework he'd written. He pitched it as a way to reduce complexity in their Serverless Python application, and as a way to simplify the unit testing. It got me thinking about how mocking the global scope of some of our dependencies was a huge PITA and that we could leverage some DI.">
    <meta property="og:url" content="https://lemonjs.uk/articles/mocking-stuff-thats-annoying-to-mock.html">
    <meta property="og:image" content="https://lemonjs.uk/images/social-bg.png">
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="630" />
    <meta property="og:site_name" content="lemonjs">
    <meta name="theme-color" content="#2f3640">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
    <link rel="manifest" href="/manifest.json">
    <link rel="stylesheet" href="/css/main.css">
    <link rel="stylesheet" href="/css/atom-one-dark.css">
    <!-- Squeaky Tracking Code for https://lemonjs.uk -->
    <script>
      (function(s,q,e,a,u,k,y){
        s._sqSettings={site_id:'63ff4985-f8aa-4a41-9ca5-16933d95f578'};
        u=q.getElementsByTagName('head')[0];
        k=q.createElement('script');k.async=1;
        k.src=e+s._sqSettings.site_id;
        u.appendChild(k);
      })(window,document,'https://cdn.squeaky.ai/g/0.1.0/script.js?');
    </script>
</head>

<body>
    <div class="container">
        <header class="header">
            <h3>lemonjs</h3>
            <a href="/">< Back</a>
        </header>
        <main>
            <article>
                <h1>Mocking stuff that's annoying to mock</h1>
                <div class="tags">
                  <span>TypeScript</span><span>Testing</span><span>Redis</span>
                </div>
                <p>I recently attended a workshop where a coworker demoed a Dependency Injection framework he'd written. He pitched it as a way to reduce complexity in their Serverless Python application, and as a way to simplify the unit testing. It got me thinking about how mocking the global scope of some of our dependencies was a huge PITA and that we could leverage some DI.</p>
                <p>We've recently started moving a leaderboard from DynamoDB to Redis and we need a way to mock some of the calls to Redis. One option would be to use <a href="https://www.npmjs.com/package/ioredis-mock" target="_blank" rel="nofollow noreferrer">ioredis-mock</a>, a drop in library to stub out the entirety of Redis. Yarn installing a whole package just to write some tests seemed like the most javascripty thing ever!</p>
                <p>Here's how I imagine our code would be structured:</p>
                <pre><code class="hljs typescript">
import Redis from 'redis';

const redis = new Redis();

export const getLeaderboardEntry = async (
  id: string
): Promise<string | null> => {
  return redis.get(id);
};

export const deleteLeaderboardEntry = async (
  id: string
): Promise<void> => {
  await redis.del(id);
};
                </code></pre>
                <p>A bunch of exported functions all utlising the global redis instance. On the face of it, this code is okay, however it has it's downsides. Firstly, getting an item from the leaderboard is now tightly coupled both to Redis, and to the specific npm package for talking to Redis. Secondly, we need to mock the global scope.</p>
                <p>Without going head first into a DI framework, we could easilly rewrite this code as a class, where we take a CacheClient argument, like so:</p>
                <pre><code class="hljs typescript">
export class Leaderboard {
  private readonly client: CacheClient;

  public constructor(client: CacheClient) {
    this.client = client;
  }

  public async get(id: string): Promise<string | null> {
    this.client.get(id);
  }

  public async delete(id: string): Promise<void> {
    this.client.del(id);
  }
}
                </code></pre>
                <p>With a small change, we've decoupled the leaderboard from Redis, from ioredis, and made it possible to test without mocking the global scope, nice! A simple test can now be written to make sure the client is called correctly:</p>
                <pre><code class="hljs typescript">
describe('Leaderboard', () => {
  describe('.get', () => {
    const client = { get: jest.fn(() => 'hello!') };

    it('calls the client', async () => {
      const leaderboard = new Leaderboard(client);
      await leaderboard.get('id');
      expect(client.get).toHaveBeenCalledWith('id');
    });

    it('returns the key', async () => {
      const leaderboard = new Leaderboard(client);
      const result = await leaderboard.get('id');
      expect(result).toEqual('hello');
    });
  });
});
                </code></pre>
                <p>Another option would be to use a Higher Order Function to inject the <code class="inline">CacheClient</code>, we could leverage all the benefits of the above class, but retain the 'just a bunch of exported functions' approach. Here's a basic wrapper:</p>
                <pre><code class="hljs typescript">
import Redis from 'ioredis';

const redis = new Redis();

const withCacheClient = <T extends Function, G>(
  func: T,
  ...args: Array<T>
) => func(x, ...args);
                </code></pre>
                <p>If we modify the code from the first example to use this HOF, it would look like this:</p>
                <pre><code class="hljs typescript">
export const getLeaderboardEntry = async (
  client: CacheClient,
  id: string
): Promise<string | null> => {
  return client.get(id);
};

export const deleteLeaderboardEntry = async (
  client: CacheClient,
  id: string
): Promise<void> => {
  await client.del(id);
};

// Example usage
async withCacheClient(getLeaderboardEntry, 'id');
async withCacheClient(deleteLeaderboardEntry, 'id');
                </code></pre>
                <p>Once again, our application logic can be tested without the need to mock the global Redis instance, as we can pass a mocked version in ourselves:</p>
                <pre><code class="hljs typescript">
describe('getLeaderboardEntry', () => {
  const client = { get: jest.fn(() => 'Hello') };

  it('returns the key', () => {
    const result = getLeaderboardEntry(redis, 'id');
    expect(result).toEqual('hello');
  });
});
            </code></pre>
            </article>
        </main>
    </div>

    <script type="text/javascript" src="/js/highlight.pack.js"></script>
    <script type="text/javascript">hljs.highlightAll();</script>
</body>

</html>