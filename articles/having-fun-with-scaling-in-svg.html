<!DOCTYPE html>
<html>
  <head>
    <title>lemonjs / articles / Having fun with scaling in SVG</title>
    <meta name="description" content="Just another developer's blog">
    <meta name="keywords" content="Blog, TypeScript, Python, Running, Coffee">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="Lewis Monteith">
    <meta property="og:title" content="Having fun with scaling in SVG">
    <meta property="og:description" content="I used to work at a SASS company that offered a web based editor that allowed users to design and build gift cards. The app was pretty old and used canvas for all of it's rendering. Although performant, canvas was shockingly bad when it came to accessibility and was not pleasant to develop for.">
    <meta property="og:url" content="https://lemonjs.uk/having-fun-with-scaling-in-svg.html">
    <meta property="og:image" content="https://lemonjs.uk/social-bg.png">
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="630" />
    <meta property="og:site_name" content="lemonjs">
    <meta name="theme-color" content="#2f3640">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/manifest.json">
    <link rel="stylesheet" href="/main.css">
  </head>
  <body>
    <div class="container">
      <header class="header">
        <h3>A bunch of nonsense, by Lewis Monteith</h3>
        <p>
          <a href="/">< Back</a>
        </p>
      </header>
      <main>
          <article>
            <h1>Having fun with scaling in SVG</h1>
            
            <p>I used to work at a SASS company that offered a web based editor that allowed users to design and build gift cards. The app was pretty old and used canvas for all of it's rendering. Although performant, canvas was shockingly bad when it came to accessibility and was not pleasant to develop for.</p>

            <p>At the time this app was built, canvas was the only choice as SVG's were not widely supported. I figured that any modern app wouldn't even bother with canvas, so I was shocked when I noticed that Figma uses canvas!</p>

            <p>I wanted to see if I could build a basic editor using purely SVG, so I created a proof of concept called <a href="https://vectorly.app" target="_blank" rel="nofollow noreferrer">Vectorly</a>. For the most part, working with SVGs is fairly straight forward. I managed to be able to create elements, move them around and rotate them. I also figured out how to convert mouse coordinates to generate SVG paths, which was integrated into a line tool.</p>

            <p>By far my largest challenge was with scaling elements. Most SVG elements do not have a width and height like they go in the DOM or in a canvas. As a result, elements paths must either be adjusted or scaled. I picked the latter for my experiment. When the user clicked and dragged on the 9-point grid, the following functions were called:</p>

              <pre><code class="language-typescript hljs"><span class="hljs-keyword">private</span> handleMouseMove = (
    event: MouseEvent
): <span class="hljs-function"><span class="hljs-params">void</span> =&gt;</span> {
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state.pressed) {
        <span class="hljs-keyword">const</span> transform = calculateTransform({
            <span class="hljs-attr">box</span>: <span class="hljs-built_in">this</span>.state.box,
            <span class="hljs-attr">client</span>: [event.clientX, event.clientY],
            <span class="hljs-attr">offset</span>: <span class="hljs-built_in">this</span>.state.offset,
            <span class="hljs-attr">scale</span>: <span class="hljs-built_in">this</span>.state.scale,
            <span class="hljs-attr">shift</span>: <span class="hljs-built_in">this</span>.state.shift,
            <span class="hljs-attr">position</span>: <span class="hljs-built_in">this</span>.props.location,
        });
        <span class="hljs-built_in">this</span>.props.handleTransform(transform);
    }
};

<span class="hljs-keyword">private</span> handkeMouseUp = (): <span class="hljs-function"><span class="hljs-params">void</span> =&gt;</span> {
    <span class="hljs-built_in">this</span>.setState({ <span class="hljs-attr">pressed</span>: <span class="hljs-literal">false</span> });
};

<span class="hljs-keyword">private</span> handleMouseDown = (
    event: React.MouseEvent&lt;SVGEllipseElement&gt;
): <span class="hljs-function"><span class="hljs-params">void</span> =&gt;</span> {
    <span class="hljs-keyword">const</span> box = <span class="hljs-built_in">this</span>.parent.getBBox();

    <span class="hljs-built_in">this</span>.setState({
        <span class="hljs-attr">box</span>: [box.width, box.height],
        <span class="hljs-attr">offset</span>: [event.clientX, event.clientY],
        <span class="hljs-attr">pressed</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">scale</span>: clone(<span class="hljs-built_in">this</span>.props.transform.s)
    });
};</code></pre>
            <p>All of this is unfotunately necessary, as an element may or may not have a scale applied before you drag, so both the offset of your drag and the scale factor need to be taken into account. All of this is made more challenging when you allow the user to zoom the editor in!</p>
            
            <p>Once you know the start position, the end position, the original coordinates, the original scale amount, whether or not the user is holding the shift key and the elements position from the top left of the SVG, you can try and figure out how much you should adjust the scale. Remember, we're not simply adjusting the width/height, that would be too easy! We need to calculate how much to adjust the X and Y scale of the element.</p>

            <p>Prepare yourself for a function that should never see the light of day!</p>
              <pre><code class="language-typescript hljs"><span class="hljs-keyword">const</span> MIN_SIZE = <span class="hljs-number">32</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> calculateTransform = (
    payload: TransformPayload
): Partial&lt;Transform&gt; =&gt; {
    <span class="hljs-keyword">const</span> { position, shift } = payload;

    <span class="hljs-keyword">const</span> [clientX, clientY] = payload.client;
    <span class="hljs-keyword">const</span> [width, height] = payload.box;
    <span class="hljs-keyword">const</span> [offsetX, offsetY] = payload.offset;
    <span class="hljs-keyword">const</span> [scaleX, scaleY] = payload.scale;

    <span class="hljs-keyword">const</span> out: Partial&lt;Transform&gt; = { <span class="hljs-attr">s</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>] };

    <span class="hljs-keyword">let</span> h = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> w = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> x: <span class="hljs-built_in">number</span> | <span class="hljs-literal">undefined</span>;
    <span class="hljs-keyword">let</span> y: <span class="hljs-built_in">number</span> | <span class="hljs-literal">undefined</span>;

    <span class="hljs-keyword">switch</span> (position) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">'top-left'</span>:
            x = offsetX + clientX - offsetX;
            y = offsetY + clientY - offsetY;
            w = (width * scaleX) - (clientX - offsetX);
            h = (height * scaleY) - (clientY - offsetY);
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-string">'top-center'</span>:
            y = offsetY + clientY - offsetY;
            w = width * scaleX;
            h = (height * scaleY) - (clientY - offsetY);
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-string">'top-right'</span>:
            w = width + (clientX - offsetX);
            h = (height * scaleY) - (clientY - offsetY);
            y = offsetY + clientY - offsetY;
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-string">'center-right'</span>:
            w = (width * scaleX) + (clientX - offsetX);
            h = height * scaleY;
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-string">'bottom-right'</span>:
            w = (width * scaleX) + (clientX - offsetX);
            h = (height * scaleY) + (clientY - offsetY);
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-string">'bottom-center'</span>:
            w = width * scaleX;
            h = (height * scaleY) + (clientY - offsetY);
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-string">'bottom-left'</span>:
            w = (width * scaleX) - (clientX - offsetX);
            h = (height * scaleY) + (clientY - offsetY);
            x = offsetX + clientX - offsetX;
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-string">'center-left'</span>:
            w = (width * scaleX) - (clientX - offsetX);
            h = height * scaleY;
            x = offsetX + clientX - offsetX;
            <span class="hljs-keyword">break</span>;
    }

    out.s = [
        <span class="hljs-built_in">Math</span>.max(w, MIN_SIZE) / width,
        <span class="hljs-built_in">Math</span>.max(h, MIN_SIZE) / height
    ];

    <span class="hljs-keyword">if</span> (x &amp;&amp; w &gt;= MIN_SIZE) out.x = x;
    <span class="hljs-keyword">if</span> (y &amp;&amp; h &gt;= MIN_SIZE) out.y = y;

    <span class="hljs-keyword">if</span> (shift) {
        <span class="hljs-keyword">const</span> aspect = width / height;
        out.s[<span class="hljs-number">1</span>] = (<span class="hljs-built_in">Math</span>.max(w, MIN_SIZE) / aspect) / height;
    }

    <span class="hljs-keyword">return</span> out;
};</code></pre>
            <p>This project has been parked, but it was a really fun exersize!</p>
          </article>
      </main>
    </div>
  </body>
</html>
