<!DOCTYPE html>
<html>
  <head>
    <title>lemonjs / articles / Improving the HackerStash leaderboard load times by 8x</title>
    <meta name="description" content="Just another developer's blog">
    <meta name="keywords" content="Blog, TypeScript, Python, Running, Coffee">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="Lewis Monteith">
    <meta property="og:title" content="Improving the HackerStash leaderboard load times by 8x">
    <meta property="og:description" content="HackerStash has a rather complicated system for calculating the score for the leaderboard as it includes the following">
    <meta property="og:url" content="https://lemonjs.uk/improving-the-hackerstash-leaderboard-load-times-by-8x.html">
    <meta property="og:image" content="https://lemonjs.uk/social-bg.png">
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="630" />
    <meta property="og:site_name" content="lemonjs">
    <meta name="theme-color" content="#2f3640">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/manifest.json">
    <link rel="stylesheet" href="/main.css">
  </head>
  <body>
    <div class="container">
      <header class="header">
        <h3>A bunch of nonsense, by Lewis Monteith</h3>
        <p>
          <a href="/">< Back</a>
        </p>
      </header>
      <main>
          <article>
            <h1>Improving the HackerStash leaderboard load times by 8x</h1>

            <p><a href="https://hackerstash.com" target="_blank" rel="noreferrer nofollow">HackerStash</a> has a rather complicated system for calculating the score for the leaderboard as it includes the following:</p>

            <ul>
              <li>sum of the votes for the project for this month (x10)</li>
              <li>sum of the votes for the posts for this month (x5)</li>
              <li>sum of the projects team members comments for this month (x1)</li>
              <li>sum of the completed challenges for this month (xN)</li>
            </ul>
            
            <p>In order to build the leaderboard, all this information must be known for every project. As you can imagine, this is a very expensive operation! Until recently I used to calculate this on the fly, then cache it in Redis for a few minutes so that subsequent queries were faster.</p>

            <p>This approach was a total hack and was not scalable. I was already seeing 1000ms response times with only ~30 projects on the leaderboard which is far too slow.</p>

            <p>After some research I decided on a Redis SortedSet as it seemed to fit the bill. I created a new class to handle the leaderboard that would be used for fetching the order of projects, as well as updating the project's score.</p>

            <p>The class looks a little something like this (simplified for your viewing pleaseure, of course):</p>

              <pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Leaderboard</span>:</span>
    key: <span class="hljs-built_in">str</span> = key()

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, project</span>):</span>
        self.project = project

<span class="hljs-meta">    @classmethod    </span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">order</span>(<span class="hljs-params">cls, reverse=<span class="hljs-literal">False</span></span>) -&gt; list[int]:</span>
        order = redis.zrevrange(cls.key, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>)
        <span class="hljs-keyword">return</span> [<span class="hljs-built_in">int</span>(x.decode(<span class="hljs-string">'utf-8'</span>)) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> order]

<span class="hljs-meta">    @classmethod    </span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">remaining_days</span>(<span class="hljs-params">cls</span>) -&gt; str:</span>
        <span class="hljs-keyword">return</span> arrow.utcnow().ceil(<span class="hljs-string">'month'</span>).humanize(only_distance=<span class="hljs-literal">True</span>)

<span class="hljs-meta">    @property    </span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">position</span>(<span class="hljs-params">self</span>) -&gt; int:</span>
        rank = redis.zrevrank(self.key, self.project.<span class="hljs-built_in">id</span>)
        <span class="hljs-keyword">return</span> rank + <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> rank <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> -<span class="hljs-number">1</span>

<span class="hljs-meta">    @property    </span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">score</span>(<span class="hljs-params">self</span>) -&gt; int:</span>
        score = redis.zscore(self.key, self.project.<span class="hljs-built_in">id</span>) <span class="hljs-keyword">or</span> <span class="hljs-number">0.0</span>
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(score)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update</span>(<span class="hljs-params">self, amount: <span class="hljs-built_in">int</span></span>) -&gt; int:</span>
        score = redis.zincrby(self.key, amount, self.project.<span class="hljs-built_in">id</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(score)</code></pre>
              <p>Let's break this down!</p>

              <p>Leaderboard#order</p>
              <p>This uses the Redis ZREVRANGE operation to get the project ids in reverse order using this months key. Redis stores the ids in a byte format, so they must be decoded into strings.</p>
                
              <p>Leaderboard#remaining_days</p>
              <p>I use a package called arrow (similar to moment.js for you Node folk) to tell us how long is left for this current tournament.</p>
                
              <p>Leaderboard#position</p>
              <p>I use the Redis ZREVRANK method to get an individual projects position. As the Set is 0 index based, I need to increment by 1.</p>
                
              <p>Leaderboard#score</p>
              <p>This uses the Redis ZSCORE method to get the current score for the project. It returns the score as a Float if it exists, or None if not. I cast to an Int as it would look a bit weird otherwise.</p>
                
              <p>Leaderboard#update</p>
              <p>This uses the Redis ZINCRBY method to increment the projects score. I call this whenever an action occurs like a vote, a simplified example looks like this:</p>

              <pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">vote</span>(<span class="hljs-params">self, direction: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span>
    score = <span class="hljs-number">5</span> <span class="hljs-keyword">if</span> direction == <span class="hljs-string">'up'</span> <span class="hljs-keyword">else</span> -<span class="hljs-number">5</span>
    vote = Vote(<span class="hljs-built_in">type</span>=<span class="hljs-string">'post'</span>, score=score)
    Leaderboard(self.project).update(score)    
    db.session.commit()</code></pre>

              <p>When fetching the leaderboard, I can first get the order and use it to work out which projects to fetch from the database, like so:</p>

              <pre><code class="hljs python"><span class="hljs-comment"># Fetch the page from the query string, default to the first page</span>
page = request.args.get(<span class="hljs-string">'page'</span>, <span class="hljs-number">1</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">int</span>)

<span class="hljs-comment"># Get a list of ids in their correct order from the above class</span>
order = Leaderboard.order()

<span class="hljs-comment"># Create an SQL expression using those orders</span>
order_expr = func.array_position(order, Project.<span class="hljs-built_in">id</span>)

<span class="hljs-comment"># Get only the projects that qualify for the leaderboard, and order</span>
<span class="hljs-comment"># them based on the order expression</span>
projects = Project.query\
    .<span class="hljs-built_in">filter</span>(Project.<span class="hljs-built_in">id</span>.in_(order))\
    .<span class="hljs-built_in">filter</span>(Project.published == <span class="hljs-literal">True</span>)\
    .order_by(order_expr)\
    .paginate(page, <span class="hljs-number">25</span>, <span class="hljs-literal">False</span>)</code></pre>
              <p>Overall, some nice gains in performance and we're left with a more future proof solution</p>
              
              <p>I wrote about this over at <a href="https://hackerstash.com/posts/how-we-improved-the-leaderboard-load-times-by-8x" target="_blank" rel="noreferrer nofollow">HackerStash</a>, you can check the speed gains out for yourself</p>
          </article>
      </main>
    </div>
  </body>
</html>
