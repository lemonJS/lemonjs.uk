<!DOCTYPE html>
<html>
  <head>
    <title>lemonjs / articles / Improving the HackerStash leaderboard load times by 8x</title>
    <meta name="description" content="Just another developer's blog">
    <meta name="keywords" content="Blog, TypeScript, Python, Runing, Coffee">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="Lewis Monteith">
    <meta property="og:title" content="Improving the HackerStash leaderboard load times by 8x">
    <meta property="og:description" content="HackerStash has a rather complicated system for calculating the score for the leaderboard as it includes the following">
    <meta property="og:url" content="https://lemonjs.uk/improving-the-hackerstash-leaderboard-load-times-by-8x.html">
    <meta property="og:image" content="https://lemonjs.uk/social-bg.png">
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="630" />
    <meta property="og:site_name" content="lemonjs">
    <meta name="theme-color" content="#2f3640">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/manifest.json">
    <link rel="stylesheet" href="/main.css">
  </head>
  <body>
    <div class="container">
      <header class="header">
        <h3>A bunch of nonsense, by Lewis Monteith</h3>
        <p>
          <a href="/">< Back</a>
        </p>
      </header>
      <main>
          <article>
            <h1>Improving the HackerStash leaderboard load times by 8x</h1>

            <p><a href="https://hackerstash.com" target="_blank" rel="noreferrer nofollow">HackerStash</a> has a rather complicated system for calculating the score for the leaderboard as it includes the following:</p>

            <ul>
              <li>sum of the votes for the project for this month (x10)</li>
              <li>sum of the votes for the posts for this month (x5)</li>
              <li>sum of the projects team members comments for this month (x1)</li>
              <li>sum of the completed challenges for this month (xN)</li>
            </ul>
            
            <p>In order to build the leaderboard, all this information must be known for every project. As you can imagine, this is a very expensive operation! Until recently I used to calculate this on the fly, then cache it in Redis for a few minutes so that subsequent queries were faster.</p>

            <p>This approach was a total hack and was not scalable. I was already seeing 1000ms response times with only ~30 projects on the leaderboard which is far too slow.</p>

            <p>After some research I decided on a Redis SortedSet as it seemed to fit the bill. I created a new class to handle the leaderboard that would be used for fetching the order of projects, as well as updating the project's score.</p>

            <p>The class looks a little something like this (simplified for your viewing pleaseure, of course):</p>

            <pre><code>class Leaderboard:    
    key: str = key()    

    def __init__(self, project):        
        self.project = project    

    @classmethod    
    def order(cls, reverse=False) -> list[int]:        
        order = redis.zrevrange(cls.key, 0, -1)        
        return [int(x.decode('utf-8')) for x in order]    

    @classmethod    
    def remaining_days(cls) -> str:        
        return arrow.utcnow().ceil('month').humanize(only_distance=True)    

    @property    
    def position(self) -> int:        
        rank = redis.zrevrank(self.key, self.project.id)        
        return rank + 1 if rank is not None else -1    

    @property    
    def score(self) -> int:        
        score = redis.zscore(self.key, self.project.id) or 0.0        
        return int(score)    

    def update(self, amount: int) -> int:        
        score = redis.zincrby(self.key, amount, self.project.id)        
        return int(score)</code></pre>
              <p>Let's break this down!</p>

              <p>Leaderboard#order</p>
              <p>This uses the Redis ZREVRANGE operation to get the project ids in reverse order using this months key. Redis stores the ids in a byte format, so they must be decoded into strings.</p>
                
              <p>Leaderboard#remaining_days</p>
              <p>I use a package called arrow (similar to moment.js for you Node folk) to tell us how long is left for this current tournament.</p>
                
              <p>Leaderboard#position</p>
              <p>I use the Redis ZREVRANK method to get an individual projects position. As the Set is 0 index based, I need to increment by 1.</p>
                
              <p>Leaderboard#score</p>
              <p>This uses the Redis ZSCORE method to get the current score for the project. It returns the score as a Float if it exists, or None if not. I cast to an Int as it would look a bit weird otherwise.</p>
                
              <p>Leaderboard#update</p>
              <p>This uses the Redis ZINCRBY method to increment the projects score. I call this whenever an action occurs like a vote, a simplified example looks like this:</p>

              <pre><code>def vote(self, direction: str) -> None:    
    score = 5 if direction == 'up' else -5    
    vote = Vote(type='post', score=score)    
    Leaderboard(self.project).update(score)    
    db.session.commit()</code></pre>

              <p>When fetching the leaderboard, I can first get the order and use it to work out which projects to fetch from the database, like so:</p>

              <pre><code># Fetch the page from the query string, default to the first page
page = request.args.get('page', 1, type=int)

# Get a list of ids in their correct order from the above class
order = Leaderboard.order()

# Create an SQL expression using those orders
order_expr = func.array_position(order, Project.id)

# Get only the projects that qualify for the leaderboard, and order
# them based on the order expression
projects = Project.query\    
    .filter(Project.id.in_(order))\    
    .filter(Project.published == True)\    
    .order_by(order_expr)\    
    .paginate(page, 25, False)</code></pre>
              <p>Overall, some nice gains in performance and we're left with a more future proof solution</p>
              
              <p>I wrote about this over at <a href="https://hackerstash.com/posts/how-we-improved-the-leaderboard-load-times-by-8x" target="_blank" rel="noreferrer nofollow">HackerStash</a>, you can check the speed gains out for yourself</p>
          </article>
      </main>
    </div>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@latest/build/highlight.min.js" crossorigin="anonymous"></script>
    <script type="text/javascript">
        hljs.highlightAll();
    </script>
  </body>
</html>