<!DOCTYPE html>
<html lang="en">

<head>
    <title>lemonjs / articles / RSpec makes testing truly enjoyable</title>
    <meta charset="utf-8">
    <meta name="description" content="Just another developer's blog">
    <meta name="keywords" content="Blog, TypeScript, Python, Running, Coffee">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="Lewis Monteith">
    <meta property="og:title" content="RSpec makes testing truly enjoyable">
    <meta property="og:description" content="My first experience writing tests was with Mocha and Chai in Node v0.10. At the time there were two phrases that every non-dev in the company was using, the first was 'mobile first' and the second was 'TDD'. I'm not sure they really understood what they were, but it was all the rage and they wanted it.">
    <meta property="og:url" content="https://lemonjs.uk/rspec-makes-testing-truly-enjoyable.html">
    <meta property="og:image" content="https://lemonjs.uk/images/social-bg.png">
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="630" />
    <meta property="og:site_name" content="lemonjs">
    <meta name="theme-color" content="#2f3640">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
    <link rel="manifest" href="/manifest.json">
    <link rel="stylesheet" href="/css/main.css">
    <link rel="stylesheet" href="/css/atom-one-dark.css">
    <!-- Squeaky Tracking Code for https://lemonjs.uk -->
    <script>
      (function(s,q,e,a,u,k,y){
        s._sqSettings={site_id:'63ff4985-f8aa-4a41-9ca5-16933d95f578'};
        u=q.getElementsByTagName('head')[0];
        k=q.createElement('script');
        k.src=e+s._sqSettings.site_id;
        u.appendChild(k);
      })(window,document,'https://cdn.squeaky.ai/g/0.3.2/script.js?');
    </script>
</head>

<body>
    <div class="container">
        <header class="header">
            <h3>lemonjs</h3>
            <a href="/">< Back</a>
        </header>
        <main>
            <article>
                <h1>RSpec makes testing truly enjoyable</h1>
                <div class="tags">
                  <span>Ruby</span><span>Testing</span>
                </div>
                <h3>A <i>little</i> backstory</h3>
                <p>My first experience writing tests was with Mocha and Chai in Node v0.10. At the time there were two phrases that every non-dev in the company was using, the first was "mobile first" and the second was "TDD". I'm not sure they really understood what they were, but it was all the rage and they wanted it.</p>
                <p>Testing at the time was always an afterthought - I would make some changes, refresh the browser and have a look for myself. Then once I knew it worked, I would go and verify my claim with some tests and call it a day.</p>
                <p>Mocha and Chai did the job in this regard, but it was never a fun job. You'd need to install some plugins for Chai to play nicely with Promises, then another plugin so that Mocha could report properly in Jenkins. You'd need to configure Superagent so that you could run queries against your Express routes. You'd need to write a function to create and teardown a database when the tests run. You need Sinon to stub stuff. It was exhausting.</p>
                <p>Fast forward a few years and now we're working with TypeScript, Babel, React etc, and there are plugins upon plugins to get all of this to work. The cold start for the test runner becomes unbearable, and any updates are likely to cause the entire thing to collapse.</p>
                <p>Jest came along and fixed about 75% of the problems. It had less boilerplate, a lot less plugins, ran concurrently, but I still didn't enjoy it.</p>
                <h3>Oh, Ruby</h3>
                <p>My first experience with Ruby was in 2019, or about 10 years after it was "cool". I initially hated Ruby (funny story, I love it now), but working with RSpec was a huge, huge eye opener to me. Most of the buzz I'd heard about 5 years prior started to make sense, and for the first time in my development career I actually started to enjoy writing tests.</p>
                <p>How much of this enjoyment comes from RSpec directly, and how much of it is due to Rails or Ruby is not that clear to me, but I suspect it's a combination of the three. Finally, tests were seperated logically, and read like they were telling a story.</p>
                <p>The devs on that team absolutely adored testing, and I have a feeling that their enthusiasm and knowledge helped change my perspective as much as the framework did. But I'll focus on the code here.</p>
                <h3>Highlights</h3>
                <p>One of my favourite features is the <code class="inline">change { }</code> matcher, it allows you to assert on the side effects that your actions have. To my knowledge, no such thing exists in the JS world. When the subject is called, we can assert that the size of team changed from 4, to 0 but here's an example:</p>
                <pre><code class="hljs ruby">
RSpec.describe Mutations::Team, type: :request do
  let(:team) { create_team(members: 4) }

  subject { described_class.delete(team) }

  it 'deletes the team members' do
    expect { subject }.to change { team.size }.from(4).to(0)
  end
end
                </code></pre>
                <p>Another thing I really like is the mocking and stubbing that is provided out of the box. Jest is quite limited, and can produce some quite clumsy looking code. Sinon is easier to follow, but neither read quite like Rspec. We can easilly mock the <code class="inline">get</code> method on <code class="inline">Net::HTTP</code> so that it returns the expected HTML. We can then assert that the subject reports the presence of the string.</p>
                <pre><code class="hljs ruby">
RSpec.describe Mutations::SiteVerify, type: :request do
  before { allow(Net::HTTP).to receive(:get).and_return('Hello world') }

  subject { described_class.verify('Hello') }

  it 'finds the word in the html response' do
    expect { subject }.to be true
  end
end    
                </code></pre>
                <p>One more thing is the magic helpers when working with specific types of tests. For example in controller test, calling the HTTP method magically makes the request, and populates the <code class="inline">response</code> variable:</p>
                <pre><code class="hljs ruby">
RSpec.describe PingController, type: :controller do
  describe 'GET /index' do
    it 'returns PONG' do
      get :index
      expect(response).to have_http_status(200)
      expect(response.body).to eq 'PONG'
    end
  end
end
                </code></pre>
                <p>Lastly, there are <code class="inline">doubles</code> and <code class="inline">instance_doubles</code>. They allow you to use a "stunt double" instead of passing around real data in your unit tests. They are strict, so any calls will raise errors unless they are expected.</p>
                <pre><code class="hljs ruby">
Rspec.describe 'Test doubles' do
  let(:cat) { double('cat') }
                  
  before { allow(cat).to receive(:meow).and_return 'MEOW!' }
                  
  it 'meows' do
    expect(cat.meow).to eq 'MEOW!'
  end
end
                </code></pre>
                <p>There is an endless amount of stuff to talk about, but safe to say, I've never encounted anything quite like this in the Node.js or Python ecosystems.</p>
            </article>
        </main>
    </div>

    <script type="text/javascript" src="/js/highlight.pack.js"></script>
    <script type="text/javascript">hljs.highlightAll();</script>
</body>

</html>