<!DOCTYPE html>
<html lang="en">

<head>
    <title>lemonjs / articles / Building a Serverless-first framework</title>
    <meta charset="utf-8">
    <meta name="description" content="Just another developer's blog">
    <meta name="keywords" content="Blog, TypeScript, Python, Running, Coffee">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="Lewis Monteith">
    <meta property="og:title" content="Building a Serverless-first framework">
    <meta property="og:description" content="Vendor lock-in is generally a bad idea, but I've found that I'm using Serverless/AWS/TypeScript for most APIs.">
    <meta property="og:url" content="https://lemonjs.uk/having-fun-with-scaling-in-svg.html">
    <meta property="og:image" content="https://lemonjs.uk/social-bg.png">
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="630" />
    <meta property="og:site_name" content="lemonjs">
    <meta name="theme-color" content="#2f3640">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/manifest.json">
    <link rel="stylesheet" href="/main.css">
</head>

<body>
    <div class="container">
        <header class="header">
            <h3>lemonjs</h3>
            <a href="/">< Back</a>
        </header>
        <main>
            <article>
                <h1>Building a Serverless-first framework</h1>
                <p>Vendor lock-in is generally a bad idea, but I've found that I'm using Serverless/AWS/TypeScript for most APIs. Whenever the API requires GraphQL, I use <a href="https://www.apollographql.com/docs/apollo-server/v1/servers/lambda/" target="_blank" rel="nofollow noreferrer">apollo-server-lambda</a> (which is fantastic), however REST APIs tend to need a lot of boilerplate. One option is to use Express with <a href="https://github.com/mikestaub/serverless-express" target="_blank" rel="nofollow noreferrer">serverless-express</a>, however, I'd like to explore the idea of building a Serverless-first framework.</p>
                <p>If we create a very basic REST handler with Serverless, it looks something like this:</p>
                <pre><code>
import { APIGatewayProxyEventV2, Context } from 'aws-lambda';

export const handle = async (
    event: APIGatewayProxyEventV2,
    context: Context
) => {
    return {
        statusCode: 200,
        body: JSON.stringify({ hello: 'world' })
    };
};
                </code></pre>
                <p>Although you can get the job done, there are some features I would like to see:</p>
                <ul>
                    <li>The response object is noisy, a Flask-like tuple would be nicer (i.e. <code class="inline">return 200, 'Hello World'</code>)</li>
                    <li>There is no ability to set defaults (i.e. cors headers)</li>
                    <li>Any Error thrown will result in a 500 Internal Server Error - I want to be able to throw an Error from anywhere within the handler that sets the correct status code</li>
                    <li>No utility helpers (i.e. setting a cookie)</li>
                </ul>
                <p>To address some of these points, I've published <a href="https://github.com/lemonJS/serverless-http-utils" target="_blank" rel="nofollow noreferrer">serverless-http-utils</a>.</p>
                <p>Using these utils, the above handler can be refactored to:</p>
                <pre><code>
import { handler, Event, HttpSuccess } from 'serverless-http-utils';

export const handle = handler((event: Event) => {
    return new HttpSuccess(200, { hello: 'world' });
});
                </code></pre>
                <p>I personally find the <code class="inline">HttpSuccess</code> class to be simpler, and adds a solid base for adding utility functions in the future.</p>
                <p>Under the hood, the handler looks like this:</p>
                <pre><code>
export const handler = (
    handle: HandlerFunction
) => async (event: Event) => {
    return handle(event).catch(error => {
        return error instanceof HttpException
            ? error
            : new HttpException(500, 'Internal Server Error');
    });
};              
                </code></pre>
                <p>With this handler, we now have the ability to throw exceptions from anywhere with the ability to set a status code and message. Errors that are not an instance of <code class="inline">HttpException</code> will return a 500 status with the matching message, this ensures that we don't dump sensitive information in our JSON response. Errors that are in fact instances of <code class="inline">HttpException</code> will return the status code and message body that were set during the throw.</p>
                <p><code class="inline">HttpException</code> extends <code class="inline">Error</code> so it's role is twofold. When thrown, it behaves like any other <code class="inline">Error</code>, however it can also be passed around like any other class.</p>
                <p>In this scenario, the 401 status code will be returned to the client, along with the message:</p>
                <pre><code>
import { handler, HttpException } from 'serverless-http-utils';

export const handle = handler((event: Event) => {
    throw new HttpException(401, 'Unauthorized');
});             
                </code></pre>
                <p>However, a regular error will be safely prevented from reaching the front end:</p>
                <pre><code>
import { handler } from 'serverless-http-utils';

export const handle = handler((event: Event) => {
    throw new Error('Yer a wizard, Harry');
});             
                </code></pre>
                <p>You can even create your own custom exceptions that extend <code class="inline">HttpException</code>.
                </p>
                <p>I plan to take these utilities and form a framework from them. Although these features are not implemented yet, I can imagine the <code class="inline">HttpSuccess</code> being extended to implement features such as cookie/header setting, for example:</p>
                <pre><code>
import { handler, Event, HttpSuccess } from 'serverless-http-utils';

export const handle = handler((event: Event) => {
    const response = new HttpSuccess();

    response.status = 204;
    response.body = null;

    response.setHeader('Access-Control-Allow-Origin': '*');
    response.setCookie('session': 'session-cookie');

    return response;
});             
                </code></pre>
                <p>Although similar to Koa or even Express, I imagine the utilities would be lightweight and highly targeted to building REST APIs with Serverless.</p>
            </article>
        </main>
    </div>
</body>

</html>