<!DOCTYPE html>
<html>
<head>
    <title>lemonjs / articles / Building a Serverless-first framework</title>
    <meta name="description" content="Just another developer's blog">
    <meta name="keywords" content="Blog, TypeScript, Python, Running, Coffee">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="Lewis Monteith">
    <meta property="og:title" content="Building a Serverless-first framework">
    <meta property="og:description" content="I used to work at a SASS company that offered a web based editor that allowed users to design and build gift cards. The app was pretty old and used canvas for all of it's rendering. Although performant, canvas was shockingly bad when it came to accessibility and was not pleasant to develop for.">
    <meta property="og:url" content="https://lemonjs.uk/having-fun-with-scaling-in-svg.html">
    <meta property="og:image" content="https://lemonjs.uk/social-bg.png">
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="630" />
    <meta property="og:site_name" content="lemonjs">
    <meta name="theme-color" content="#2f3640">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/manifest.json">
    <link rel="stylesheet" href="/main.css">
</head>
<body>
    <div class="container">
        <header class="header">
            <h3>A bunch of nonsense, by Lewis Monteith</h3>
            <p>
                <a href="/">< Back</a>
            </p>
        </header>
        <main>
            <article>
                <h1>Building a Serverless-first framework</h1>

                <p>Vendor lock-in is generally a bad idea, but I've found that I'm using Serverless/AWS/TypeScript for most APIs. Whenever the API requires GraphQL, I use <a href="https://www.apollographql.com/docs/apollo-server/v1/servers/lambda/" target="_blank" rel="nofollow noreferrer">apollo-server-lambda</a> (which is fantastic), however REST APIs tend to need a lot of boilerplate. One option is to use Express with <a href="https://github.com/mikestaub/serverless-express" target="_blank" rel="nofollow noreferrer">serverless-express</a>, however, I'd like to explore the idea of building a Serverless-first framework.</p>

                <p>If we create a very basic REST handler with Serverless, it looks something like this:</p>
                <pre><code class="language-typescript hljs"><span class="hljs-keyword">import</span> { APIGatewayProxyEventV2, Context } <span class="hljs-keyword">from</span> <span class="hljs-string">'aws-lambda'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> handle = <span class="hljs-keyword">async</span> (
    event: APIGatewayProxyEventV2,
    <span class="hljs-attr">context</span>: Context
) =&gt; {
    <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">statusCode</span>: <span class="hljs-number">200</span>,
        <span class="hljs-attr">body</span>: <span class="hljs-built_in">JSON</span>.stringify({ <span class="hljs-attr">hello</span>: <span class="hljs-string">'world'</span> })
    };
};</code></pre>
            <p>Although you can get the job done, there are some features I would like to see:</p>
            <ul>
                <li>The response object is noisy, a Flask-like tuple would be nicer (i.e. <code class="inline">return 200, 'Hello World'</code>)</li>
                <li>There is no ability to set defaults (i.e. cors headers)</li>
                <li>Any Error thrown will result in a 500 Internal Server Error - I want to be able to throw an Error from anywhere within the handler that sets the correct status code</li>
                <li>No utility helpers (i.e. setting a cookie)</li>
            </ul>

            <p>To address some of these points, I've published <a href="https://github.com/lemonJS/serverless-http-utils" target="_blank" rel="nofollow noreferrer">serverless-http-utils</a>.</p>

            <p>Using these utils, the above handler can be refactored to:</p>
            <pre><code class="language-typescript hljs"><span class="hljs-keyword">import</span> { handler, Event, HttpSuccess } <span class="hljs-keyword">from</span> <span class="hljs-string">'serverless-http-utils'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> handle = handler(<span class="hljs-function">(<span class="hljs-params">event: Event</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HttpSuccess(<span class="hljs-number">200</span>, { <span class="hljs-attr">hello</span>: <span class="hljs-string">'world'</span> });
});</code></pre>

                <p>I personally find the <code class="inline">HttpSuccess</code> class to be simpler, and adds a solid base for adding utility functions in the future.</p>

                <p>Under the hood, the handler looks like this:</p>

                <pre><code class="language-typescript hljs"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> handler = <span class="hljs-function">(<span class="hljs-params">
        handle: HandlerFunction
</span>) =&gt;</span> <span class="hljs-keyword">async</span> (event: Event) =&gt; {
    <span class="hljs-keyword">return</span> handle(event).catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {
        <span class="hljs-keyword">return</span> error <span class="hljs-keyword">instanceof</span> HttpException
          ? error
          : <span class="hljs-keyword">new</span> HttpException(<span class="hljs-number">500</span>, <span class="hljs-string">'Internal Server Error'</span>);
    });
};</code></pre>

            <p>With this handler, we now have the ability to throw exceptions from anywhere with the ability to set a status code and message. Errors that are not an instance of <code class="inline">HttpException</code> will return a 500 status with the matching message, this ensures that we don't dump sensitive information in our JSON response. Errors that are in fact instances of <code class="inline">HttpException</code> will return the status code and message body that were set during the throw.</p>

            <p><code class="inline">HttpException</code> extends <code class="inline">Error</code> so it's role is twofold. When thrown, it behaves like any other <code class="inline">Error</code>, however it can also be passed around like any other class.</p>

            <p>In this scenario, the 401 status code will be returned to the client, along with the message:</p>

            <pre><code class="language-typescript hljs"><span class="hljs-keyword">import</span> { handle, HttpException } <span class="hljs-keyword">from</span> <span class="hljs-string">'serverless-http-utils'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> handle = handler(<span class="hljs-function">(<span class="hljs-params">event: Event</span>) =&gt;</span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> HttpException(<span class="hljs-number">401</span>, <span class="hljs-string">'Unauthorized'</span>);
});</code></pre>

                <p>However, a regular error will be safely prevented from reaching the front end:</p>

                <pre><code class="language-typescript hljs"><span class="hljs-keyword">import</span> { handle } <span class="hljs-keyword">from</span> <span class="hljs-string">'serverless-http-utils'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> handle = handler(<span class="hljs-function">(<span class="hljs-params">event: Event</span>) =&gt;</span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Yer a wizard, Harry'</span>);
});</code></pre>

                <p>You can even create your own custom exceptions that extend <code class="inline">HttpException</code></p>

                <p>I plan to take these utilities and form a framework from them. Although these features are not implemented yet, I can imagine the <code class="inline">HttpSuccess</code> being extended to implement features such as cookie/header setting, for example:</p>

            <pre><code class="language-typescript hljs"><span class="hljs-keyword">import</span> { handler, Event, HttpSuccess } <span class="hljs-keyword">from</span> <span class="hljs-string">'serverless-http-utils'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> handle = handler(<span class="hljs-function">(<span class="hljs-params">event: Event</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">new</span> HttpSuccess();

    response.status = <span class="hljs-number">204</span>;
    response.body = <span class="hljs-literal">null</span>;

    response.setHeader(<span class="hljs-string">'Access-Control-Allow-Origin'</span>: <span class="hljs-string">'*'</span>);
    response.setCookie(<span class="hljs-string">'session'</span>: <span class="hljs-string">'session-cookie'</span>);

    <span class="hljs-keyword">return</span> response;
});</code></pre>

                <p>Although similar to Koa or even Express, I imagine the utilities would be lightweight and highly targeted to building REST APIs with Serverless.</p>
            </article>
        </main>
    </div>
</body>
</html>
